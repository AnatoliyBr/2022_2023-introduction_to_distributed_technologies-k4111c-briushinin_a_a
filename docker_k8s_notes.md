# Kubernetes для пользователей

Бесплатный курс на Stepic [Kubernetes для пользователей](https://stepik.org/course/99188/syllabus).

---
## Docker

### Как уменьшить размер образа? - MultiStage сборка образов
Одним из самых простых шагов по оптимизации контейнерных развертываний Docker является использование **меньших базовых образов** и **MultiStage сборка** - создание временного и финального образа на базе легковесного Alpine. **Alpine** – это легкий дистрибутив Linux, разработанный для обеспечения безопасности и эффективности использования ресурсов.

### Как уменьшить время сборки образа?
Dockerfile имеет луковую архитектуру, и каждый слой накладывается на следующий. Слои создают команды FROM, RUN, COPY, и ADD. Если вышестоящий слой изменяется, то нижележащие будут **пересобираться** (кэш на нижних работать не будет). Именно поэтому то, что меняется реже всего записывается в Dockerfile как можно **выше**.

### Docker best practice
* MultiStage сборка образов
* Минимизация количества слоев
* Расположение статичных слоев как можно выше

---
## Kubernetes (K8S)

### Как взаимодействовать с K8S?
С помощью kubectl мы можем взаимодействовать с ресурсами K8S **двумя** способами.

* Императивно - указывать сделать, что мы хотим.

* Декларативно - описать в yaml-манифесте, что мы хотим и просить сделать.

Всегда разворачиваете приложения **декларативно**!

### Команды kubectl
* Смена кластеров  
    * config
* Создание, изменение, удаление объектов  
    * create
    * apply
    * edit
    * delete
* Просмотр информации об объектах
    * get
    * describe
    * logs
    * top
* Проброс портов
    * port-forward
* Работа с версиями развертывания
    * rollout

> Если вы столкнетесь с какими-либо проблемами в работе Подов, используйте `describe` - одной из первых команд в debug'е проблемы.

### Namespace
Namespaces позволяют нам разградить Поды разных приложений или разных команд. Вы можете представлять Под, как файлик, а Namespace с Подами как папку. Одна команда имеет доступ к папке и файлам внутри, другая - нет. 

Чтобы декларативно создать пространство имен, пишем manifest-file:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: new-namespace
```

Применяем манифест в K8S - `kubectl apply -f namespace.yaml`.
Проверяем, что создали namespace - `kubectl get ns`.

### Service
* ClusterIP
    * Обеспечивает сервис **внутри кластера** - внешнего доступа нет
    * Недостаток: выбор этого сервиса делает Под доступным только изнутри кластера, т.е. есть риск потерять внешний IP адрес при переезде Pod
* LoadBalancer
    * Позволяет открыть внешний доступ и жестко привязать внешний IP адрес к Pod (например, можно поднять реплику БД со статичным IP адресом)
    *  Недостаток: ограниченность IPv4 адресов
* NodePort
    * Открывает на всех Нодах кластера порт, запросы попадающие на этот порт будут перенаправлены в ваш Pod
    * Недостаток: порты доступны в интервале 30000–32767

### Controller
* Deployment
    * на самом деле это контроллер контроллера ReplicaSet, который отслеживает количество реплик, контроллер Деплоймент расширяет этот функционал
* DaemonSet
    * поддерживает по одной реплике Pod на каждой из Node кластера
* Job
    * поднимает Pod, отрабатывает и помирает до следующего запуска
* CronJob
    * Job, который запускается по расписанию

### Хранение данных в K8S
* ConfigMap
    * хранение конфигурационных данных
    * объем данных не может превышать 1 Мб 
* Secret
    * хранение конфиденциальных данных
    * данные кодируется в base64
* EmptyDir
    * данный том предназначен для хранения небольших данных
    * создается пустым (отсюда и название) на сервере, где лежит Pod в оперативной памяти или на диске
    * существует, пока будет жив его Pod
* Persistent Volume Claim
    * хранение постоянных данных приложений
    * для использования PVC, необходимо, чтобы в кластере был реализован интерфейс CSI (Container Storage Interface) администратором кластера
    * PVC своего рода запрос необходимого постоянного тома (диска)

### Helm
[Helm](https://helm.sh/docs/intro/quickstart/) - инструмент для шаблонизации манифестов.

Теперь можно подтягивать значения параметров из .yaml файла автоматически.

Для создания шаблона (chart) необходимо скачать **бинарную утилиту** Helm.

Командой `helm create test-chart` можно создать целое дерево для шаблонов с разными ресурсами K8S.

Например, манифест секрета, в котором значение пароля будет браться из `value.yaml` файла.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ .Values.secret.name }}
stringData:
  password: {{ .Values.secret.password }}
```
Сам value.yaml

```yaml
image: ksxack/lesson1:v0.2
replicas: 2
secret:
  name: load-secret
  password: 1234
```

Переменные добавляются с помощью конструкции `{{ }}`, если конструкция `{{ .Values... }}`, то значение переменной подставится из файла `values.yaml`, но есть и Helm переменные в стиле `{{ .Release.Name }}`

Установка Helm релиза:  
`helm install my-helm-release  test-chart -n tst-namespace -f test-chart/values.yaml`

* helm install - запуск установки
* my-helm-release - имя релиза ( {{ .Release.Name }} )
* test-chart - папка с самим Chart
* -f test-chart/values.yaml - файл, из которого подтягиваются переменные

Удаление релиза - `helm uninstall my-helm-release`.

Собрание архива с Chart - `helm package test-chart`

> Helm помогает легко переиспользовать приложения.

### Requests, Limits, QoS
**Requests** - это то количество ресурсов (mi CPU, миллиядра CPU), которое Pod занимает на Node (worker).

> Если Node расчитана на 1000 mi, то 3 микросервиса по 400 mi не поместяться.

**Limits** - приложения в Pod могут в моменте давать больше нагрузки, чем Вы ожидаете, например Java любит во время старта приложения выжирать весь CPU, который только может, поэтому можно поставить верхнюю границу ресурсов (limit) больше, чем request.

Фрагмент манифеста с описанием Pod.
```yaml
resources:
  requests:
    memory: "100Mi"
    cpu: "200m"
  limits:
    memory: "100Mi"
    cpu: "200m"
```

В K8S cуществуют **три класса QoS** (Quality of Service):

* Best Effort
    * requests и limits вообще не указаны
* Burstable
    * requests != limits
* Guaranted
    * requests = limits

> Приоритет классов: Guaranted > Burstable > Best Effort