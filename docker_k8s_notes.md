# Kubernetes для пользователей

Бесплатный курс на Stepic [Kubernetes для пользователей](https://stepik.org/course/99188/syllabus).

---
## Docker

### Как уменьшить размер образа? - MultiStage сборка образов
Одним из самых простых шагов по оптимизации контейнерных развертываний Docker является использование **меньших базовых образов** и **MultiStage сборка** - создание временного и финального образа на базе легковесного Alpine. **Alpine** – это легкий дистрибутив Linux, разработанный для обеспечения безопасности и эффективности использования ресурсов.

### Как уменьшить время сборки образа?
Dockerfile имеет луковую архитектуру, и каждый слой накладывается на следующий. Слои создают команды FROM, RUN, COPY, и ADD. Если вышестоящий слой изменяется, то нижележащие будут **пересобираться** (кэш на нижних работать не будет). Именно поэтому то, что меняется реже всего записывается в Dockerfile как можно **выше**.

### Docker best practice
* MultiStage сборка образов
* Минимизация количества слоев
* Расположение статичных слоев как можно выше

---
## Kubernetes (K8S)

### Как взаимодействовать с K8S?
С помощью kubectl мы можем взаимодействовать с ресурсами K8S **двумя** способами.

* Императивно - указывать сделать, что мы хотим.

* Декларативно - описать в yaml-манифесте, что мы хотим и просить сделать.

Всегда разворачиваете приложения **декларативно**!

### Команды kubectl
* Смена кластеров  
    * config
* Создание, изменение, удаление объектов  
    * create
    * apply
    * edit
    * delete
* Просмотр информации об объектах
    * get
    * describe
    * logs
    * top
* Проброс портов
    * port-forward
* Работа с версиями развертывания
    * rollout

> Если вы столкнетесь с какими-либо проблемами в работе Подов, используйте `describe` - одной из первых команд в debug'е проблемы.

### Namespace
Namespaces позволяют нам разградить Поды разных приложений или разных команд. Вы можете представлять Под, как файлик, а Namespace с Подами как папку. Одна команда имеет доступ к папке и файлам внутри, другая - нет. 

Чтобы декларативно создать пространство имен, пишем manifest-file:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: new-namespace
```

Применяем манифест в K8S - `kubectl apply -f namespace.yaml`.
Проверяем, что создали namespace - `kubectl get ns`.

### Service
* ClusterIP
    * Обеспечивает сервис **внутри кластера** - внешнего доступа нет
    * Недостаток: выбор этого сервиса делает Под доступным только изнутри кластера, т.е. есть риск потерять внешний IP адрес при переезде Pod
* LoadBalancer
    * Позволяет открыть внешний доступ и жестко привязать внешний IP адрес к Pod (например, можно поднять реплику БД со статичным IP адресом)
    *  Недостаток: ограниченность IPv4 адресов
* NodePort
    * Открывает на всех Нодах кластера порт, запросы попадающие на этот порт будут перенаправлены в ваш Pod
    * Недостаток: порты доступны в интервале 30000–32767

### Controller
* Deployment
    * на самом деле это контроллер контроллера ReplicaSet, который отслеживает количество реплик, контроллер Деплоймент расширяет этот функционал
* DaemonSet
    * поддерживает по одной реплике Pod на каждой из Node кластера
* Job
    * поднимает Pod, отрабатывает и помирает до следующего запуска
* CronJob
    * Job, который запускается по расписанию

### Хранение данных в K8S
* ConfigMap
    * хранение конфигурационных данных
    * объем данных не может превышать 1 Мб 
* Secret
    * хранение конфиденциальных данных
    * данные кодируется в base64
* EmptyDir
    * данный том предназначен для хранения небольших данных
    * создается пустым (отсюда и название) на сервере, где лежит Pod в оперативной памяти или на диске
    * существует, пока будет жив его Pod
* Persistent Volume Claim
    * хранение постоянных данных приложений
    * для использования PVC, необходимо, чтобы в кластере был реализован интерфейс CSI (Container Storage Interface) администратором кластера
    * PVC своего рода запрос необходимого постоянного тома (диска)

### Helm
[Helm](https://helm.sh/docs/intro/quickstart/) - инструмент для шаблонизации манифестов.

Теперь можно подтягивать значения параметров из .yaml файла автоматически.

Для создания шаблона (chart) необходимо скачать **бинарную утилиту** Helm.

Командой `helm create test-chart` можно создать целое дерево для шаблонов с разными ресурсами K8S.

Например, манифест секрета, в котором значение пароля будет браться из `value.yaml` файла.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ .Values.secret.name }}
stringData:
  password: {{ .Values.secret.password }}
```
Сам value.yaml

```yaml
image: ksxack/lesson1:v0.2
replicas: 2
secret:
  name: load-secret
  password: 1234
```

Переменные добавляются с помощью конструкции `{{ }}`, если конструкция `{{ .Values... }}`, то значение переменной подставится из файла `values.yaml`, но есть и Helm переменные в стиле `{{ .Release.Name }}`

Установка Helm релиза:  
`helm install my-helm-release  test-chart -n tst-namespace -f test-chart/values.yaml`

* helm install - запуск установки
* my-helm-release - имя релиза ( {{ .Release.Name }} )
* test-chart - папка с самим Chart
* -f test-chart/values.yaml - файл, из которого подтягиваются переменные

Удаление релиза - `helm uninstall my-helm-release`.

Собрание архива с Chart - `helm package test-chart`

> Helm помогает легко переиспользовать приложения.

### Requests, Limits, QoS
**Requests** - это то количество ресурсов (mi CPU, миллиядра CPU), которое Pod занимает на Node (worker).

> Если Node расчитана на 1000 mi, то 3 микросервиса по 400 mi не поместяться.

**Limits** - приложения в Pod могут в моменте давать больше нагрузки, чем Вы ожидаете, например Java любит во время старта приложения выжирать весь CPU, который только может, поэтому можно поставить верхнюю границу ресурсов (limit) больше, чем request.

Фрагмент манифеста с описанием Pod.
```yaml
resources:
  requests:
    memory: "100Mi"
    cpu: "200m"
  limits:
    memory: "100Mi"
    cpu: "200m"
```

В K8S cуществуют **три класса QoS** (Quality of Service):

* Best Effort
    * requests и limits вообще не указаны
* Burstable
    * requests != limits
* Guaranted
    * requests = limits

> Приоритет классов: Guaranted > Burstable > Best Effort

### Probes

Одна из проблем, связанных с архитектурой распределенных систем и микросервисов — это автоматическое обнаружение неисправных приложений, перенаправление запросов в другие доступные системы и восстановление поврежденных компонентов.

**Проверки работоспособности** — один из способов решения этой проблемы и обеспечения надежности. В K8S проверки работоспособности настраиваются с помощью **проб** для определения состояния каждого модуля.

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    image: registry.k8s.io/busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5
      periodSeconds: 5
      failureThreshold: 4
      timeoutSeconds: 2
      successThreshold: 2
```

Таким образом, Probe добавляется к описанию контейнера (например, в манифесте Pod) и содержит перечень и количество проверок:

* `initialDelaySeconds: 5` - проводить первую проверку после 5 секунд после запуска Pod
* `periodSeconds: 5` - проводить проверку каждые 5 секунд
* `failureThreshold: 4` - проводить 4 повторных проверки перед restart
* `timeoutSeconds: 2` - время ожидания ответа на проверку 2 секунды
* `successThreshold: 2` - минимальная серия успешных проверок после неудачной

В данном случае, если приложение запустилось, поработало пару часов, зависло и совсем не отвечает, оно будет рестартовано спустя 22 секунды.

Существуют три вида Probe:
* livenessProbe
    * позволяет делать health-check и в случае провала всех проверок K8S перезапустит контейнер в Pod
* readinessProbe
    * позволяет проверить загруженность Pod и в случае провала всех проверок K8S service перестанет посылать запросы на Pod
* startupProbe
    * имеет наивысший приоритет, решает проблему CrashLoop при долгом старте приложения
    * если она настроена, liveness и readiness проверки не будут отрабатывать, пока не завершится работа startup проверки

### Horizontal Pod Autoscaler
Horizontal Pod Autoscaler - ресурс K8S, позволяющий масштабировать приложение, то есть добавлять новые реплики.

### Предоставление доступа
Role Based Access Contol - основной механизм управления доступами в K8S.

Существует несколько **ресурсов** K8S для управления доступом:
* Role - это совокупность прав, которые впоследствии могут быть привязаны к пользователю
* RoleBinding - чтобы привязать эту роль к конкретному пользователю, используйте RoleBinding
* ServiceAccount - если необходимо взаимодействовать с API Kubernetes из Pod, понадобится создать ServiceAccount. Чтобы дать SA права также используется ресурс RoleBinding

> Разница пользователя и SA в том, что SA существует лишь в рамках namespace.

