# Список вопросов к экзамену в рамках курса "Введение в распределенные технологии 2022/2023"

## Виртуализация и контейнеризация

### 1. Что такое виртуализация? Какие виды бывают, чем виртуализация отличается от контейнеризации и отличается ли?
Эти вопросы разобраны в моей [технической статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md) в главе **Функции ядра Linux и контейнеры**, в параграфе **Виртуальные машины vs Контейнеры**.

**Виртуализация** - это построение вычислительной среды, в которой на базе одних и тех же аппаратных ресурсов работает множество изолированных друг от друга виртуальных машин.

**Виртуальная машина** - это программа, которая эмулирует (имитирует) работу другой программы.

> Главная идея виртуализации - оптимизация расходывания вычислительных ресурсов.

* [Виртуальная машина (Yandex Cloud)](https://cloud.yandex.ru/docs/glossary/vm)
* [Что такое виртуализация? (Yandex Cloud)](https://cloud.yandex.ru/docs/glossary/virtualization)

### 2. Что такое docker, rkt, containerd? Как работает контейнеризация в одной из выбранных систем на выбор? (Полное объяснение с работой сетей и т.д)
**Docker** - платформа контейнеризации, архитектура описана во [второй лекции](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md).

**rkt (Rocket)** - аналог Docker (на данный момент проект закрыт).

**containerd** - высокоуровневая среда выполнения контейнеров. Подробное описание работы контейнеризации и связь containerd с Docker и Kubernetes есть в моей [технической статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md).

[Обзор](https://docs.docker.com/network/) сетевого взаимодействия в Docker из официальной документации. Также отмечу полезную [статью](https://itisgood.ru/2019/10/29/objasnenie-koncepcii-setej-v-docker/) и [видеолекцию](https://www.youtube.com/watch?v=ctJnI43ermQ).

В Docker существуют различные типы сетей, которые подключаются с помощью соответствующих **драйверов (network drivers)**:

* **bridge** - сеть по-умолчанию, позволяет связать несколько контейнеров **на одном host'е**.
    * Сеть видна/доступна на host'е (главном компьютере) под именем **docker0**
    * Когда контейнеры запускаются и подключаются к мостовым сетям, создается **пара сетевых сокетов**:
        * Один присваивается контейнеру как **eth0**
        * А другой присваивается/подключается к мосту как **vethX**, где X - случайная строка
    * Контейнер наследует настройку DNS демона docker (от host'а)
    * В этой сети нет технологии **обнаружения сервисов (Service Discovery)**
        * Однако при создании **пользовательской (user-defined)** мостовой сети обнаружение сервисов будет
    
* **host** - позволяет контейнеру совместно использовать сетевое пространство имен host'а.
    * **Удаляется сетевая изоляция** между контейнером и host'ом 
    * Если запустить контейнер, который привязывается к порту 80, и использует host-сеть, то приложение контейнера доступно через порт 80 по IP-адресу host'а
        * Это значит, что вы не сможете запускать несколько контейнеров на одном host'е, на одном и том же порту, так как порт теперь является общим для всех контейнеров в сети host'а
    * Контейнеру не выделяется IP-адрес, он совместно использует его с host'ом (то есть **не создается пара сокетов**)
    * Полезно для **оптимизации производительности**, так как **не требуется NAT** между host'ом и контейнером. Никакой "пользовательский прокси-сервер" не создается для каждого порта контейнера
        * NAT (англ. Network Address Translation) - преобразование сетевых адресов. Предназначен для упрощения и сохранения IP-адресов. [Nat на пальцах: что это?](https://wiki.merionet.ru/seti/13/nat-na-palcax-chto-eto/)
    * Сеть host'a работает только на host'ах **Linux**

* **none (null)** - в сети такого типа контейнеры не подключены ни к одной сети и не имеют доступа к внешней сети или другим контейнерам.
    * Полезно, когда требуется полностью отключить сетевой стек в контейнере

* **overlay** - этот драйвер позволяет строить сети **на нескольких host'ах** с Docker (обычно на Docker Swarm кластере) с помощью инкапсуляции пакетов.
    * Драйвер cоздает внутреннюю частную сеть, которая охватывает все узлы, участвующие в кластере swarm.

* **macvlan** - позволяет назначить MAC-адрес контейнеру, чтобы он отображался как физическое устройство в сети.
    * Docker-демон будет направлять трафик в контейнеры по их MAC-адресам
    * Использование драйвера macvlan целесообразно при работе с устаревшими приложениями, которые ожидают прямого подключения к физической сети, а не маршрутизации через сетевой стек узла Docker
    * Полезно, при переходе с виртуальной машины или когда, нужно,чтобы контейнеры выглядели как физические узлы в сети, каждый с уникальным MAC-адресом

* **Network plugins** - сторонние плагины позволяют интегрировать Docker со специализированными сетевыми стеками.

* **ipvlan** - предоставляет пользователям полный контроль над IPv4 и IPv6-адресацией.

С помощью команды `docker network ls` можно вывести список сетей по умолчанию, их будет три:
* none
* host
* bridge

Сети по умолчанию подробно описаны в статье: [Docker Networking Deep Dive](https://github.com/KamranAzeem/learn-docker/blob/master/docs/docker-networking-deep-dive.md).

Остальные сетевык команды docker можно посмотреть командой: `docker network --help`.

Наиболее часто используют **Bridge** и **Overlay** сети, они хорошо описаны [здесь](https://habr.com/ru/company/flant/blog/521406/):

* Контейнеры на **одном** host'е можно связать **Linux-мостом (Bridge network)**, для этого необходимо создать **виртуальные устройства** [veth (virtual ethernet device)](https://man7.org/linux/man-pages/man4/veth.4.html). Один конец veth-устройства подключается к сетевому пространству имен контейнера, другой - к Linux-мосту в сети host'а. У всех контейнеров на одном host'е один из концов veth подключен к мосту, через который они могут связываться друг с другом по IP-адресам.
    * **У Linux-моста также имеется IP-адрес**, и он выступает в качестве шлюза для исходящего (egress) трафика из Pod'ов, предназначенного для других узлов.

* Контейнеры на **разных** host'ах можно связать по IP-адресам с помощью **инкапсуляции пакетов (Overlay network)**. Во Flannel за эту возможность отвечает технология [vxlan](https://vincent.bernat.ch/en/blog/2017-vxlan-linux), которая «упаковывает» исходный пакет в пакет **UDP** и затем отправляет его по назначению.
    * Полезно, когда нам **не хватает пространства IP-адресов** или сеть не может управлять дополнительными маршрутами. Или когда мы хотим получить **дополнительные возможности управления**, предоставляемые оверлеями.
    * Инкапсуляция-декапсуляция всех пакетов добавляет небольшую **задержку** и **сложность**

IPTables rules

### 3. Что такое kubernetes? Архитектура, работа служебных сервисов, методы организации развертывания контейнеров
**Kubernetes** - это платформа оркестрации контейнеров для автоматизации развертывания, масштабирования и управления контейнерными приложениями. Задача Kubernetes заключается в **координации кластера** компьютеров, работающего как **одно целое**. Абстрактные объекты в Kubernetes позволяют развертывать контейнеризированные приложения в кластер, не привязывая их к отдельным машинам.

**Архитектура** Kubernetes подробно разобрана во [второй](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md) лекции.

* **Control Plane** - предоставляет API и интерфейсы для определения, развертывания и управления жизненным циклом контейнеров.
    * kube-apiserver - предоставляет Kubernetes API
* **Node** - это рабочая машина в Kubernetes.

* Kubernetes позволяет приложениям абстрагироваться от инфраструктуры, давая нам простое API, к которому можно отправлять запросы.
* Kubernetes способствует стандартизации работы с провайдерами облачных услуг (Cloud Service Provider, CSP).

Работа **служебных сервисов** описана в моей [статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md).

**Container Runtime Interface (CRI)** определяет API между Kubernetes и Container Runtime. Данный стандарт позволил Kubernetes не интегрироваться с Docker, а использовать среды выполнения напрямую, если они соответствуют спецификации.

**Container Networking Interface (CNI)** - набор требований к исполняемой среде контейнеров (container runtimes) и плагинам (plugins), соответствие которым позволяет любому плагину работать с любым runtime'ом.

**Развертывание** Kubernetes-кластеров подробно разобрано в [пятой](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md) лекции.

* **On-premise (на железе)** - вам предоставляется ВМ и вы руками что-то устанавливаете на конкретные компьютеры.
    * kubeadm, kubectl, kubelet, CRI 
    * Для быстрого развертывания использовать систему для удаленного управления конфигурациями Ansible
* **Cloud (в облаке)** - компания предоставляет услугу по выделенным вычислениям, которые выполняются на их инфраструктуре.
    * GCP

### 4. Что такое Pod, Deployment - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов
**Pod** - минимальная развертываемая единица в K8S, набор из одного и более контейнеров, имеющих общее пространство имен и тома общей файловой системы.

Надо отметить, что контейнеры имеют собственные **изолированные** файловые системы, но они могут **совместно** использовать данные, пользуясь ресурсом K8S, который называется **Volume (том)**.

Важным архитектурным принципом сетевого устройства Kubernetes является то, что каждый Pod обладает уникальным IP-адресом. **IP Pod'а делится между всеми его контейнерами** и является доступным (маршрутизируемым) для всех остальных Pod'ов.

Для описания пода пишут **манифест (manifest file)**, шаблон которого есть в документации.

Для создания корректного описания манифеста в **YAML-формате** достаточно знать только два типа структур:
* списки (lists)
* мапы (maps)

Шаблон манифеста Pod'а:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: vault
  labels:
    app: lab1
spec:
  containers:
    - name: vault
      image: vault
      ports:
        - containerPort: 8200
```

Что важно:
1. Задать тип ресурса (`kind: Pod`)
2. Задать имя ресурса в metadata (`name: vault`)
3. Добавить метку в metadata (`app: lab1`)
4. Задать имя контейнера, образ, порт (`name`, `image`, `ports`)

**Deployment** - ресурс K8S, который позволяет автоматизировать процесс перехода от одной версии приложения к другой без прерывания работы системы. В нем описывается **желаемое** состояние системы. Deploymnet предоставляет декларативные обновления для Pod'ов и ReplicaSet'ов.

Отвечает за:
* Поддержание системы в нужном состоянии (например, если мы удалим из развертывания 1 Pod, K8S запустет другой)
* Выполнение развёртываний с нулевым временем простоя системы
* Откат к предыдущему состоянию системы

На самом деле Deployment относится к такому виду ресурсов K8S как **Controller**, которых существует 5 типов:
* ReplicaSet - поддерживает определенное число Pod'ов в системе
* Deployment - на самом деле это контроллер контроллера ReplicaSet, который отслеживает количество реплик, контроллер Deployment расширяет этот функционал
* DaemonSet - поддерживает по одной реплике Pod на каждой из Node кластера
* Job - поднимает Pod, отрабатывает и помирает до следующего запуска
* CronJob - Job, который запускается по расписанию

Шаблон манифеста Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend_pod
  template:
    metadata:
      labels:
        app: frontend_pod
    spec:
      containers:
      - name: frontend-container
        image: ifilyaninitmo/itdt-contained-frontend:master
        ports:
        - containerPort: 3000
        env:
        - name: REACT_APP_USERNAME
          value: Anatolii
        - name: REACT_APP_COMPANY_NAME
          value: ITMO
```

Что важно:
1. Задать тип ресурса (`kind: Deployment`)
2. Задать имя ресурса в metadata (`name: frontend`)
3. Добавить метку в metadata (`app: frontend`)
4. Задать число копий Pod'a в spec (`replicas: 2`), в документации принято обозначать, как поле `.spec.replicas`
5. В поле `.spec.selector.matchLabels` задается по каким метками, созданный ресурс будет находить Pod'ы, которыми он управляет
6. Шаблон Pod'а задается в объекте `template`. С помощью свойства `env` объявляем внутри Pod'ов переменные окружения `REACT_APP_USERNAME` и `REACT_APP_COMPANY_NAME` со значениями `Anatolii` и `ITMO`, соответственно.

### 5. Что такое Service и Ingress? - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов

**Service** - это ресурс, который определяет логический набор Pod'ов и политику (правила) доступа к ним (иногда этот шаблон называют микросервисом).

Набор Pod'ов, на которые нацелен сервис определяется selector'ом.

Существует несколько типо сервисов (поле `type`):
* ClusterIP
    * Обеспечивает сервис **внутри кластера** - внешнего доступа нет
    * Тип сервиса по-умолчанию
    * Недостаток: выбор этого сервиса делает Pod доступным только изнутри кластера, т.е. есть риск потерять внешний IP адрес при переезде Pod
* LoadBalancer
    * Позволяет открыть внешний доступ и жестко привязать внешний IP адрес к Pod (например, можно поднять реплику БД со статичным IP адресом)
    * Недостаток: ограниченность IPv4 адресов
* NodePort
    * Открывает на всех Нодах кластера порт, запросы попадающие на этот порт будут перенаправлены в ваш Pod
    * Недостаток: порты доступны в интервале 30000–32767
* ExternalName

Шаблон манифеста Service (типа NodePort)
```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  labels:
    app: lab3-frontend
spec:
  type: NodePort
  selector:
    app: lab3-frontend
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
      nodePort: 30333
```

Что важно:
1. Задать тип ресурса (`kind: Service`)
2. Задать имя ресурса в metadata (`name: frontend-service`)
3. Добавить метку в metadata (`app: lab3-frontend`)
4. Задать тип сервиса (`type: NodePort`)
5. В поле `.spec.selector` задается метка, определяющая на какие Pod'ы будет нацелен сервис
6. В поле `port` указывается, какой порт прослушивает сервис, а в поле `targetPort` на какой порт он будет перенаправлять трафик
7. В зависимости от типа сервиса настройки портов будут отличаться, в данном случае есть поле `nodePort`, весь трафик, приходящий на него, будет перенаправлен на `targetPort` 

Для удобства в `port` и `targePort` устанавливают одно и то же число.

**Ingress** - ресурс K8S, с помощью которого мы можем задать единую точку входа в кластер. Ingress позволяет нам назначить для каждого сервиса свой [URL](https://ru.wikipedia.org/wiki/URL), доступный вне кластера.

Ingress предоставляет доступ к маршрутам HTTP и HTTPS из-за пределов кластера к сервисам внутри кластера. Маршрутизация трафика контролируется правилами, определенными на Ingress ресурсе.

Чтобы использовать Ingress нужен **Ingress Controller** (например, можно развернуть **ingress-nginx**)

Манифест Ingress
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: frontend-ingress
spec:
  tls:
  - hosts:
      - frontend-lab3.anatolii
    secretName: lab3-tls
  rules:
  - host: frontend-lab3.anatolii
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 3000
```
Что важно:
1. Для Ingress требуются поля `apiVersion`, `kind`, `metadata` и `spec`.
2. Имя Ingress объекта в metadata должно быть допустимым именем поддомена DNS (`name: frontend-ingress`)
3. Пропущено поле `.spec.ingressClassName`, потому что некоторые Ingress controller'ы работают без определения IngressClassName, например **ingress-nginx**
4. В поле `.spec.rules` описываются **правила** (`rules`) маршрутизации трафика:
* `host` - необязательное поле, если host не указан, правило применяется ко всему входящему HTTP-трафику через указанный IP-адрес, иначе правила применяются к этому хосту (как в примере)
    * В полях hosts и host указываем доменное имя (FQDN) - frontend-lab3.anatolii
* Каждый путь `path` имеет `pathType`, всего есть три вида pathType:
    * ImplementationSpecific
    * Exact
    * Prefix
* В поле `backend` указываются сервисы и номера портов
    * HTTP (и HTTPS) запросы к Ingress, которые соответствуют `host` и `path` в правилах (`rules`), отправляются на указанный сервер (backend)

TLS сертификат представляет собой технологию безопасности, с помощью которой шифруется связь между браузером и сервером: сертификат с публичным ключом для шифрования, приватный ключ для расшифровки.

## Дополнительные материалы

### Разница между IP-адресом и MAC-адресом
**MAC-адрес** - это физический адрес, **идентифицирующий** фактическое устройство в локальной сети.
* MAC - Media Access Control
* 48-битный (6 байт) шестнадцатеричный адрес
* Канальный (2) уровень сетевой модели OSI
* Записан на **сетевую интерфейсную карту (NIC)** устройства, поэтому его можно изменить, только заменив NIC

**IP-адрес** - это логический адрес, **характеризующий местоположение** вашего устройства в сети Интернет.
* IP - Internet Protocol
* Виды адреса (разные версии протокола):
    * IPv4 - это 32-битный (4 байта) адрес
    * IPv6 - это 128-битный (16 байт) адрес
* Сетевой (3) уровень сетевой модели OSI
* IP-адреса обычно предоставляются администратором сети или Интернет-провайдерами (ISP, Internet service provider)
* Люди редко используют IP номера адресов напрямую, вместо этого используют **DNS-имена**, которые приложение переводит в соответствующий номер

### Разница между TCP и UDP протоколами
TCP и UDP протоколы - основные протоколы Траспортного (4) уровня модели OSI.

**TCP (Transmission Control Protocol, протокол управления передачей)** - это протокол, который гарантирует доставку данных в корректном виде (например, с помощью контрольной суммы).
* Он жёстко следит за каждым битом информации, но работает гораздо медленнее UDP.
* Используется например, при авторизации - нам важно передать последовательность символов в правильном порядке.
* TCP-пакет намного сложнее, чем UDP

**UDP (User Datagram Protocol, протокол пользовательских датаграмм)** - протокол, который не проверяет цельность битов, его задача - как можно быстрее передать данные с одного устройства на другое.
* Используется например, при передачи видео или аудио - там, где небольшие потери некритичны, зато важна скорость передачи данных.
* Несмотря на то, что UDP не гарантирует доставку, в нем помимо портов и IP есть поле контрольной суммы.

Полезные ссылки:
* [Что такое модель OSI и зачем она нужна: препарируем слоёный пирог интернета](https://skillbox.ru/media/code/chto-takoe-model-osi-i-zachem-ona-nuzhna-prepariruem-sloyenyy-pirog-interneta/)
* [Разница между IP-адресом и MAC-адресом](https://raznisa.ru/raznica-mezhdu-ip-adresom-i-mac-adresom/)
* [TCP против UDP или будущее сетевых протоколов](https://habr.com/ru/company/oleg-bunin/blog/461829/)

### vlan, vxlan, macvlan, veth
**vlan (Virtual Local Area Network, виртуальная локальная компьютерная сеть)** - группа устройств, имеющих возможность взаимодействовать между собой напрямую на Канальном (2) уровне, хотя физически при этом они могут быть подключены к разным сетевым коммутаторам.
* vlan основывается на работе протокола **802.1q**
* Используется для разделения подсетей
* В отличие от Ethernet-кадра 802.1q-кадр содержит **Тег**
* Самое популярное применение vlan-ов: логическое объединение узлов в группы независимо от их физического расположения, то есть изоляция одной группы узлов от другой. Очень удобно, когда сотрудники физически работают в разных местах, но должны быть объединены. И конечно с точки зрения безопасности vlan не заменимы. Главное, чтобы к сетевым устройствам имели доступ ограниченный круг лиц. Добились ограничения на Канальном (2) уровне.
* [Основы компьютерных сетей. Тема №6. Понятие VLAN, Trunk и протоколы VTP и DTP](https://habr.com/ru/post/319080/)

**vxlan (Virtual Extensible LAN, виртуальная расширяемая локальная сеть)** - это протокол туннелирования. Он решает проблему недостаточного количества идентификаторов vlan (всего 4096) при разделении крупномасштабных сетей.

**macvlan** - это, по сути, Linux switch, который основан на **статичном соответствии MAC и VLAN**. Здесь используется unicast-фильтрация, не promiscuous-режим. macvlan может работать в режиме private, VEPA, bridge, passthru. macvlan - это reverse VLAN в Linux. Данная технология позволяет взять один реальный интерфейс и сделать на его основе несколько виртуальных с разными MAC-адресами.

**veth (Виртуальный Ethernet)** - это локальный туннель Ethernet.

**Сетевой интерфейс** - физическое или виртуальное устройство, предназначенное для передачи данных между программами через компьютерную сеть.
* eth - сетевой интерфейс к карте Ethernet или картам WaveLan (Radio Ethernet).
* wlan - сетевой интерфейс wi-fi адаптеров
