# Список вопросов к экзамену в рамках курса "Введение в распределенные технологии 2022/2023"

## Виртуализация и контейнеризация

### 1. Что такое виртуализация? Какие виды бывают, чем виртуализация отличается от контейнеризации и отличается ли?
Эти вопросы разобраны в моей [технической статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md) в главе **Функции ядра Linux и контейнеры**, в параграфе **Виртуальные машины vs Контейнеры**.

**Виртуализация** - это построение вычислительной среды, в которой на базе одних и тех же аппаратных ресурсов работает множество изолированных друг от друга виртуальных машин.

**Виртуальная машина** - это программа, которая эмулирует (имитирует) работу другой программы.

> Главная идея виртуализации - оптимизация расходывания вычислительных ресурсов.

* [Виртуальная машина (Yandex Cloud)](https://cloud.yandex.ru/docs/glossary/vm)
* [Что такое виртуализация? (Yandex Cloud)](https://cloud.yandex.ru/docs/glossary/virtualization)

---
### 2. Что такое docker, rkt, containerd? Как работает контейнеризация в одной из выбранных систем на выбор? (Полное объяснение с работой сетей и т.д)
**Docker** - платформа контейнеризации, архитектура описана во [второй лекции](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md).

**rkt (Rocket)** - аналог Docker (на данный момент проект закрыт).

**containerd** - высокоуровневая среда выполнения контейнеров. Подробное описание работы контейнеризации и связь containerd с Docker и Kubernetes есть в моей [технической статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md).

[Обзор](https://docs.docker.com/network/) сетевого взаимодействия в Docker из официальной документации. Также отмечу полезную [статью](https://itisgood.ru/2019/10/29/objasnenie-koncepcii-setej-v-docker/) и [видеолекцию](https://www.youtube.com/watch?v=ctJnI43ermQ).

В Docker существуют различные типы сетей, которые подключаются с помощью соответствующих **драйверов (network drivers)**:

* **bridge** - сеть по-умолчанию, позволяет связать несколько контейнеров **на одном host'е**.
    * Сеть видна/доступна на host'е (главном компьютере) под именем **docker0**
    * Когда контейнеры запускаются и подключаются к мостовым сетям, создается **пара сетевых сокетов**:
        * Один присваивается контейнеру как **eth0**
        * А другой присваивается/подключается к мосту как **vethX**, где X - случайная строка
    * Контейнер наследует настройку DNS демона docker (от host'а)
    * В этой сети нет технологии **обнаружения сервисов (Service Discovery)**
        * Однако при создании **пользовательской (user-defined)** мостовой сети обнаружение сервисов будет
    
* **host** - позволяет контейнеру совместно использовать сетевое пространство имен host'а.
    * **Удаляется сетевая изоляция** между контейнером и host'ом 
    * Если запустить контейнер, который привязывается к порту 80, и использует host-сеть, то приложение контейнера доступно через порт 80 по IP-адресу host'а
        * Это значит, что вы не сможете запускать несколько контейнеров на одном host'е, на одном и том же порту, так как порт теперь является общим для всех контейнеров в сети host'а
    * Контейнеру не выделяется IP-адрес, он совместно использует его с host'ом (то есть **не создается пара сокетов**)
    * Полезно для **оптимизации производительности**, так как **не требуется NAT** между host'ом и контейнером. Никакой "пользовательский прокси-сервер" не создается для каждого порта контейнера
        * NAT (англ. Network Address Translation) - преобразование сетевых адресов. Предназначен для упрощения и сохранения IP-адресов. [Nat на пальцах: что это?](https://wiki.merionet.ru/seti/13/nat-na-palcax-chto-eto/)
    * Сеть host'a работает только на host'ах **Linux**

* **none (null)** - в сети такого типа контейнеры не подключены ни к одной сети и не имеют доступа к внешней сети или другим контейнерам.
    * Полезно, когда требуется полностью отключить сетевой стек в контейнере

* **overlay** - этот драйвер позволяет строить сети **на нескольких host'ах** с Docker (обычно на Docker Swarm кластере) с помощью инкапсуляции пакетов.
    * Драйвер cоздает внутреннюю частную сеть, которая охватывает все узлы, участвующие в кластере swarm.

* **macvlan** - позволяет назначить MAC-адрес контейнеру, чтобы он отображался как физическое устройство в сети.
    * Docker-демон будет направлять трафик в контейнеры по их MAC-адресам
    * Использование драйвера macvlan целесообразно при работе с устаревшими приложениями, которые ожидают прямого подключения к физической сети, а не маршрутизации через сетевой стек узла Docker
    * Полезно, при переходе с виртуальной машины или когда, нужно,чтобы контейнеры выглядели как физические узлы в сети, каждый с уникальным MAC-адресом

* **Network plugins** - сторонние плагины позволяют интегрировать Docker со специализированными сетевыми стеками.

* **ipvlan** - предоставляет пользователям полный контроль над IPv4 и IPv6-адресацией.

С помощью команды `docker network ls` можно вывести список сетей по умолчанию, их будет три:
* none
* host
* bridge

Сети по умолчанию подробно описаны в статье: [Docker Networking Deep Dive](https://github.com/KamranAzeem/learn-docker/blob/master/docs/docker-networking-deep-dive.md).

Остальные сетевык команды docker можно посмотреть командой: `docker network --help`.

Наиболее часто используют **Bridge** и **Overlay** сети, они хорошо описаны [здесь](https://habr.com/ru/company/flant/blog/521406/):

* Контейнеры на **одном** host'е можно связать **Linux-мостом (Bridge network)**, для этого необходимо создать **виртуальные устройства** [veth (virtual ethernet device)](https://man7.org/linux/man-pages/man4/veth.4.html). Один конец veth-устройства подключается к сетевому пространству имен контейнера, другой - к Linux-мосту в сети host'а. У всех контейнеров на одном host'е один из концов veth подключен к мосту, через который они могут связываться друг с другом по IP-адресам.
    * **У Linux-моста также имеется IP-адрес**, и он выступает в качестве шлюза для исходящего (egress) трафика из Pod'ов, предназначенного для других узлов.

* Контейнеры на **разных** host'ах можно связать по IP-адресам с помощью **инкапсуляции пакетов (Overlay network)**. Во Flannel за эту возможность отвечает технология [vxlan](https://vincent.bernat.ch/en/blog/2017-vxlan-linux), которая «упаковывает» исходный пакет в пакет **UDP** и затем отправляет его по назначению.
    * Полезно, когда нам **не хватает пространства IP-адресов** или сеть не может управлять дополнительными маршрутами. Или когда мы хотим получить **дополнительные возможности управления**, предоставляемые оверлеями.
    * Инкапсуляция-декапсуляция всех пакетов добавляет небольшую **задержку** и **сложность**

IPTables rules

---
### 3. Что такое kubernetes? Архитектура, работа служебных сервисов, методы организации развертывания контейнеров
**Kubernetes** - это платформа оркестрации контейнеров для автоматизации развертывания, масштабирования и управления контейнерными приложениями. Задача Kubernetes заключается в **координации кластера** компьютеров, работающего как **одно целое**. Абстрактные объекты в Kubernetes позволяют развертывать контейнеризированные приложения в кластер, не привязывая их к отдельным машинам.

**Архитектура** Kubernetes подробно разобрана во [второй](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md) лекции. Кроме того, рекомендую данную [статью](https://habr.com/ru/company/flant/blog/583660/).

> Kubernetes — это всего лишь пять бинарников.

* **Control Plane** - предоставляет API и интерфейсы для определения, развертывания и управления жизненным циклом контейнеров.
    * kube-apiserver - предоставляет Kubernetes API
* **Node** - это рабочая машина в Kubernetes.

* Kubernetes позволяет приложениям абстрагироваться от инфраструктуры, давая нам простое API, к которому можно отправлять запросы.
* Kubernetes способствует стандартизации работы с провайдерами облачных услуг (Cloud Service Provider, CSP).

Работа **служебных сервисов** описана в моей [статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md).

**Container Runtime Interface (CRI)** определяет API между Kubernetes и Container Runtime. Данный стандарт позволил Kubernetes не интегрироваться с Docker, а использовать среды выполнения напрямую, если они соответствуют спецификации.

**Container Networking Interface (CNI)** - набор требований к исполняемой среде контейнеров (container runtimes) и плагинам (plugins), соответствие которым позволяет любому плагину работать с любым runtime'ом.

**Развертывание** Kubernetes-кластеров подробно разобрано в [пятой](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md) лекции.

* **On-premise (на железе)** - вам предоставляется ВМ и вы руками что-то устанавливаете на конкретные компьютеры.
    * kubeadm, kubectl, kubelet, CRI 
    * Для быстрого развертывания использовать систему для удаленного управления конфигурациями Ansible
* **Cloud (в облаке)** - компания предоставляет услугу по выделенным вычислениям, которые выполняются на их инфраструктуре.
    * GCP

---
### 4. Что такое Pod, Deployment - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов
**Pod** - минимальная развертываемая единица в K8S, набор из одного и более контейнеров, имеющих общее пространство имен и тома общей файловой системы.

Надо отметить, что контейнеры имеют собственные **изолированные** файловые системы, но они могут **совместно** использовать данные, пользуясь ресурсом K8S, который называется **Volume (том)**.

Важным архитектурным принципом сетевого устройства Kubernetes является то, что каждый Pod обладает уникальным IP-адресом. **IP Pod'а делится между всеми его контейнерами** и является доступным (маршрутизируемым) для всех остальных Pod'ов.

Для описания пода пишут **манифест (manifest file)**, шаблон которого есть в документации.

Для создания корректного описания манифеста в **YAML-формате** достаточно знать только два типа структур:
* списки (lists)
* мапы (maps)

Шаблон манифеста Pod'а:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: vault
  labels:
    app: lab1
spec:
  containers:
    - name: vault
      image: vault
      ports:
        - containerPort: 8200
```

Что важно:
1. Задать тип ресурса (`kind: Pod`)
2. Задать имя ресурса в metadata (`name: vault`)
3. Добавить метку в metadata (`app: lab1`)
4. Задать имя контейнера, образ, порт (`name`, `image`, `ports`)

**Deployment** - ресурс K8S, который позволяет автоматизировать процесс перехода от одной версии приложения к другой без прерывания работы системы. В нем описывается **желаемое** состояние системы. Deploymnet предоставляет декларативные обновления для Pod'ов и ReplicaSet'ов.

Отвечает за:
* Поддержание системы в нужном состоянии (например, если мы удалим из развертывания 1 Pod, K8S запустет другой)
* Выполнение развёртываний с нулевым временем простоя системы
* Откат к предыдущему состоянию системы

На самом деле Deployment относится к такому виду ресурсов K8S как **Controller**, которых существует 5 типов:
* ReplicaSet - поддерживает определенное число Pod'ов в системе
* Deployment - на самом деле это контроллер контроллера ReplicaSet, который отслеживает количество реплик, контроллер Deployment расширяет этот функционал
* DaemonSet - поддерживает по одной реплике Pod на каждой из Node кластера
* Job - поднимает Pod, отрабатывает и помирает до следующего запуска
* CronJob - Job, который запускается по расписанию

Шаблон манифеста Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend_pod
  template:
    metadata:
      labels:
        app: frontend_pod
    spec:
      containers:
      - name: frontend-container
        image: ifilyaninitmo/itdt-contained-frontend:master
        ports:
        - containerPort: 3000
        env:
        - name: REACT_APP_USERNAME
          value: Anatolii
        - name: REACT_APP_COMPANY_NAME
          value: ITMO
```

Что важно:
1. Задать тип ресурса (`kind: Deployment`)
2. Задать имя ресурса в metadata (`name: frontend`)
3. Добавить метку в metadata (`app: frontend`)
4. Задать число копий Pod'a в spec (`replicas: 2`), в документации принято обозначать, как поле `.spec.replicas`
5. В поле `.spec.selector.matchLabels` задается по каким метками, созданный ресурс будет находить Pod'ы, которыми он управляет
6. Шаблон Pod'а задается в объекте `template`. С помощью свойства `env` объявляем внутри Pod'ов переменные окружения `REACT_APP_USERNAME` и `REACT_APP_COMPANY_NAME` со значениями `Anatolii` и `ITMO`, соответственно.

---
### 5. Что такое Service и Ingress? - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов

**Service** - это ресурс, который определяет логический набор Pod'ов и политику (правила) доступа к ним (иногда этот шаблон называют микросервисом).

Набор Pod'ов, на которые нацелен сервис определяется selector'ом.

Существует несколько типо сервисов (поле `type`):
* ClusterIP
    * Обеспечивает сервис **внутри кластера** - внешнего доступа нет
    * Тип сервиса по-умолчанию
    * Недостаток: выбор этого сервиса делает Pod доступным только изнутри кластера, т.е. есть риск потерять внешний IP адрес при переезде Pod
* LoadBalancer
    * Позволяет открыть внешний доступ и жестко привязать внешний IP адрес к Pod (например, можно поднять реплику БД со статичным IP адресом)
    * Недостаток: ограниченность IPv4 адресов
* NodePort
    * Открывает на всех Нодах кластера порт, запросы попадающие на этот порт будут перенаправлены в ваш Pod
    * Недостаток: порты доступны в интервале 30000–32767
* ExternalName

Шаблон манифеста Service (типа NodePort)
```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  labels:
    app: lab3-frontend
spec:
  type: NodePort
  selector:
    app: lab3-frontend
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
      nodePort: 30333
```

Что важно:
1. Задать тип ресурса (`kind: Service`)
2. Задать имя ресурса в metadata (`name: frontend-service`)
3. Добавить метку в metadata (`app: lab3-frontend`)
4. Задать тип сервиса (`type: NodePort`)
5. В поле `.spec.selector` задается метка, определяющая на какие Pod'ы будет нацелен сервис
6. В поле `port` указывается, какой порт прослушивает сервис, а в поле `targetPort` на какой порт он будет перенаправлять трафик
7. В зависимости от типа сервиса настройки портов будут отличаться, в данном случае есть поле `nodePort`, весь трафик, приходящий на него, будет перенаправлен на `targetPort` 

Для удобства в `port` и `targePort` устанавливают одно и то же число.

**Ingress** - ресурс K8S, с помощью которого мы можем задать единую точку входа в кластер. Ingress позволяет нам назначить для каждого сервиса свой [URL](https://ru.wikipedia.org/wiki/URL), доступный вне кластера.

Ingress предоставляет доступ к маршрутам HTTP и HTTPS из-за пределов кластера к сервисам внутри кластера. Маршрутизация трафика контролируется правилами, определенными на Ingress ресурсе.

Чтобы использовать Ingress нужен **Ingress Controller** (например, можно развернуть **ingress-nginx**)

Манифест Ingress
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: frontend-ingress
spec:
  tls:
  - hosts:
      - frontend-lab3.anatolii
    secretName: lab3-tls
  rules:
  - host: frontend-lab3.anatolii
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 3000
```
Что важно:
1. Для Ingress требуются поля `apiVersion`, `kind`, `metadata` и `spec`.
2. Имя Ingress объекта в metadata должно быть допустимым именем поддомена DNS (`name: frontend-ingress`)
3. Пропущено поле `.spec.ingressClassName`, потому что некоторые Ingress controller'ы работают без определения IngressClassName, например **ingress-nginx**
4. В поле `.spec.rules` описываются **правила** (`rules`) маршрутизации трафика:
* `host` - необязательное поле, если host не указан, правило применяется ко всему входящему HTTP-трафику через указанный IP-адрес, иначе правила применяются к этому хосту (как в примере)
    * В полях hosts и host указываем доменное имя (FQDN) - frontend-lab3.anatolii
* Каждый путь `path` имеет `pathType`, всего есть три вида pathType:
    * ImplementationSpecific
    * Exact
    * Prefix
* В поле `backend` указываются сервисы и номера портов
    * HTTP (и HTTPS) запросы к Ingress, которые соответствуют `host` и `path` в правилах (`rules`), отправляются на указанный сервер (backend)

TLS сертификат представляет собой технологию безопасности, с помощью которой шифруется связь между браузером и сервером: сертификат с публичным ключом для шифрования, приватный ключ для расшифровки.

---
### 6. Что такое ConfigMap и Secrets? - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов
Для хранения данных в K8S существует **4 типа** ресурсов:
* **ConfigMap** - это объект API, используемый для хранения **неконфиденциальных** данных в парах ключ-значение.
    * позволяют разделить данные конфигурации и код приложения
    * объем данных не может превышать 1 Мб

Манифест ConfigMap
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-configmap
data:
  react_app_user_name: "Anatolii"
  react_app_company_name: "ITMO"
```

Что важно:
1. Задать тип ресурса (`kind: ConfigMap`)
2. Задать имя ресурса в metadata (`name: frontend-configmap`)
3. Задать данные в поле `.data` можно двумя способами (в примере задано первым - ключ-значение):
* property-like keys
* file-like keys

Через CongigMap можно задать значение переменной окружения Pod'a:
```yaml
env:
- name: REACT_APP_USERNAME
  valueFrom:
    configMapKeyRef:
        name: frontend-configmap
        key: react_app_user_name
- name: REACT_APP_COMPANY_NAME
  valueFrom:
    configMapKeyRef:
        name: frontend-configmap
        key: react_app_company_name

```

* **Secret** - это объект, содержащий небольшое количество **конфиденциальных** данных, таких как пароль, токен или ключ.
    * по сути это те же ConfigMaps только для хранения конфиденциальных данных
    * данные кодируется в base64

Манифест Secret
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  USER_NAME: YWRtaW4=
  PASSWORD: MWYyZDFlMmU2N2Rm
```

Что важно:
1. Задать тип ресурса (`kind: Secret`)
2. Задать имя ресурса в metadata (`name: mysecret`)
3. Задать тип (`type`) секрета - это облегчает программную обработку секретных данных, типов около 8:    
    * Opaque - произвольные пользовательские данные
    * tls - данные для клиента или сервера TLS (как было в лабораторной #3, но там я создавал секрет с помощью команды: `kubectl create secret tls lab3-tls --cert=lab3.crt --key=lab3.key`)
    * и т.д.
4. Задать данные в поле `.data`

* EmptyDir
    * данный том предназначен для хранения небольших данных
    * создается пустым (отсюда и название) на сервере, где лежит Pod в оперативной памяти или на диске
    * существует, пока будет жив его Pod

* Persistent Volume Claim
    * хранение постоянных данных приложений
    * для использования PVC, необходимо, чтобы в кластере был реализован интерфейс CSI (Container Storage Interface) администратором кластера
    * PVC своего рода запрос необходимого постоянного тома (диска)

---
### 7. Как работают CNI, типы CNI, особенности развертывания и эксплуатации
Чтобы разобраться какую роль играет **Интерфейс контейнерной сети (CNI)** в системе, K8S рекомендую прочитать статью [Как pod в Kubernetes получает IP-адрес](https://habr.com/ru/company/flant/blog/521406/).

Проект **CNI** представляет собой **спецификацию** для организации универсального сетевого решения для Linux-контейнеров.

Другими словами, **CNI** - **набор требований** к исполняемой среде контейнеров (container runtimes) и плагинам (plugins), соответствие которым позволяет любому плагину работать с любым runtime'ом.

CNI состоит из 4 частей:
* **Спецификация** - определяет обязательные поддерживаемые операции (добавление и удаление контейнера из сети), список параметров, формат конфигурации сети и их списков.
* **Плагины CNI (CNI plugin)** - это исполняемые файлы, соответствующие спецификации. Существуют плагины, отвечающие за различные функции **при настройке сети** Pod'а. Разбиты на 4 категории:
    * main (loopback, bridge, ptp, vlan, ipvlan, macvlan)
    * ipam (dhcp, host-local)
    * meta (flannel, tuning)
    * sample
* Библиотеки - это реализации спецификации CNI (тоже на языке Go) для удобного использования в исполняемых средах контейнеров.
* Сторонние плагины - обеспечивают поддержку различных современных решений для Linux-контейнеров.
    * **Project Calico** (виртуальная сеть L3)
    * **Weave** (простая сеть для multi-host Docker-инсталляций)
    * **Contiv Netplugin** (политики/ACL/QoS и другие возможности для контейнеров в кластерных установках типа multi-host)
    * **Flannel** (сетевая фабрика для контейнеров от CoreOS)
    * SR-IOV, Cilium (BPF/XDP), Multus (плагин Multi для Kubernetes от Intel), VMware NSX

CNI, который используется в Minikube по-умолчанию, не поддерживает никакую NetworkPolicy, поэтому необходимо установить другую CNI - **Calico**.

**Calico** является **сетевым "провайдером"**, который обеспечивает каждому Pod'у в кластере свой IP.

У каждого сетевого провайдера имеется свой **CNI plugin**.

> Runtime контейнера запускает CNI plugin, чтобы **сконфигурировать сеть** для Pod'a в процессе его запуска.

При этом у каждого провайдера есть свой **агент**. Он устанавливается во все узлы K8S и **отвечает за сетевую настройку** Pod'ов. Этот агент идет либо в комплекте с конфигом CNI, либо самостоятельно создает его на узле. Конфиг помогает CRI plugin установить, какой CNI plugin вызывать.

**Что происходит при создании Pod'a?**  
**kubelet** вызывает **CRI plugin**, чтобы создать Pod, а тот уже вызывает **CNI plugin** для настройки сети Pod'а. При этом CNI plugin сетевого провайдера (например, Calico) вызывает другие базовые CNI plugins для настройки различных аспектов сети.

> kubelet -> CRI plugin -> CNI plugin -> configure the Pod network

Таким образом, CNI отвечает за организацию сетевого взаимодействия в K8S.

---
### 8. Что такое etcd и зачем он нужен? Как обновить Kubernetes?
**etcd (key-value store)** - база данных, типа ключ-значение, как MongoDB, там хранятся все переменные, по сути туда записывается состояние системы, K8S кластер можно полностью восстановить, имея резервную копию etcd.

В K8S API-server по сути является CRUD-приложением, то есть выполняет функции (create read update delete), поэтому чтобы хранить данные ему нужна база-данных (etcd).

**Почему не SQL?**  
Принципы резервной БД API-сервера:
* Согласованность (это требование исключает NoSQL и некоторые SQL БД)
* Доступность ([CAP теорема](https://ru.wikipedia.org/wiki/Теорема_CAP))
* Стабильная производительность
* Уведомления об изменениях
* Другие соображения
    * Большие наборы данных
    * Сложные запросы

**etcd** - строго согласованное распределенное хранилище ключ-значение:
* **строго согласованное**
    * практически говоря: после успешной записи от одного клиента другой клиент никогда не увидит устаревшие данные перед записью (это не относится в конечном итоге к согласованным базам данных NoSQL)
* **распределенное**
    * в отличие от традиционных баз данных SQL, etcd разработан с нуля для запуска с несколькими узлами
    * высокую доступность (хотя и не 100%) без ущерба для согласованности.
 * **ключ-значение**
    * в отличие от баз данных SQL, модель данных etcd проста и включает ключи и значения вместо произвольных связей данных
    * это помогает ему обеспечить относительно предсказуемую производительность, по крайней мере, по сравнению с традиционными базами данных SQL.

> killer feature: etcd позволяет клиентам подписываться на изменения определенного ключа или набора ключей.

Полезная [статья](https://learnk8s.io/etcd-kubernetes) по теме.

**Как обновить Kubernetes кластер?**  
[Инструкция](https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/) из официальной документации.

Способы обновления кластера будут зависеть от того, как его изначально развернули.

Обновление производится с помощью инструмента **kubeadm**.

Глобально нужно будет:
* Обновить мастер-Node
    * Call "kubeadm upgrade" - `kubeadm upgrade plan` и `kubeadm upgrade apply v1.26.x`
    * Drain (слить) the node - `kubectl drain <node-to-drain> --ignore-daemonsets`
    * Upgrade kubelet and kubectl
        * Restart the kubelet
    * Uncordon (откорректировать) the node - `kubectl uncordon <node-to-uncordon>`
* Обновить клиент (например, kubectl)
* Обновить рабочие Node'ы в кластере
    * Upgrade kubeadm
    * Call "kubeadm upgrade" - `kubeadm upgrade node`
    * Drain the node
    * Upgrade kubelet and kubectl
        * Restart the kubelet
    * Uncordon the node
* Скорректировать манифесты и другие ресурсы на основе изменений API
    * kubectl convert

---
## Блокчейн технологии

### 9. Стек блокчейн-технологий. Уровневая модель стека
Тема хорошо раскрыта в англоязычной [статье](https://cehv.com/cehvs-blockchain-osi-model-thesis/).

Введение:
* Широкое распространение блокчейн технологии возможно благодаря приложениям, которые будут абстрагировать пользователя от всех технологий и использовать тот протокол, который удобнее (также как это произошло с Интернетом - сейчас пользователь взаимодействует лишь с 7 уровнем Приложения сетевой модели OSI и не знает, что происходит на других уровнях стека, например ему все равно используется IPv4 или IPv6)
* Можно составить аналог OSI для бизнеса - где денежная оценка потенциала компании напрямую зависит от масштаба задач, которые она решает (есть крупные компании, которые управляют малым бизнесом, а есть мелкие компании, которые решает нишевую проблему для подмножества пользователей)
* Три сектора ценности потенциала:
  * Стимулирующие сектора
    * Они в основном состоят из физического уровня, уровня канала передачи данных и сетевого уровня
    * Пример компании: Verizon Communications
  * Сектора стандартов
    * Ценность определяется созданием единого стандарта внедрения и вспомогательных услуг на его основе
    * Пример компании: Adobe’s PDF
  * Секторы взаимодействия
    * Самые ценные - это технологические бренды и стартапы, с которыми пользователи часто взаимодействуют, причем взаимодействуют через приложения (то есть не задумываются, что за протоколы используются)
    * Примеры компаний: Microsoft, Amazon, Facebook
* Если создать гибридную модель OSI Блокчейна, можно понять куда нужно инвестировать

Модель OSI Блокчейна:
* 11-уровневая модель OSI Blockchain направлена на разделение **протоколов блокчейна** и **децентрализованных приложений** ("dApps") по уровням, которые представляют собой разделение как по **технологии**, так и по **назначению**
* Каждый из 11 уровней примерно (хотя и с выбросами) варьируется от:
  * самого низкого до самого высокого **уровней абстракции** для конечных пользователей (запущенные узлы по сравнению с использованием MetaMask) и 
  * самого низкого до самого высокого **уровней извлечения максимальной потенциальной ценности** (аппаратное обеспечение с низкой маржой, абстракция с высокой маржинальной платой за протоколы взаимодействия)
* Уровни (по возрастанию):
  1. **Физический** - инфраструктура
  2. **Канальный** - ПО физического уровня
  3. **Сетевой** - соединяет два любых физических узла
  * Микросетевой - состоит из используемого нами протокола блокчейна (например, Ethereum) и передачи данных между узлами по классическим интернет-протоколам сетевого уровня (TCP/IP)
  * Макросетевой - это инструменты и протоколы, которые соединяют узлы вместе
  4. **Информационный** - набор стандартов, процедур и протоколов того, как мы индексируем, храним и сортируем информацию
  5. **Обрабатывающий** - один из самых широких и разнообразных с точки зрения его конкретных конечных целей
  6. **Представления** - один из наиболее важных уровней для роста и развития открытой системы, и все же он часто является наиболее недофинансируемым, наименее прибыльным и наиболее забытым в любой модели систем
  7. **Программный** - создает инструменты, которые мы используем для разработки, развертывания и управления программами прикладного уровня или уровня взаимодействия, часто используя для этого существующие стандарты уровня представления
  8. **Приложения** - это то место, где большинство пользователей взаимодействуют с реальными программами, использующими коллекции базовых протоколов.
  9. **Взаимодействия** - это специальные программные наборы инструментов, которые позволяют пользователям легко взаимодействовать с приложениями, а иногда и с протоколами более низкого уровня стека (**Metamask**)
  10. **Платформы** - еще не был зафиксирован в пространстве блокчейна
  11. **Расчетный / регулирования (Settlement ?)** - абстрактный слой
  * это магистраль, соединяющая несколько слоев вместе
  * это универсальная истина, окончательность и безопасность (это то, чего не существует в классическом Интернете)

Итоги:
* На сегодняшний день проблема блокчейн сферы в том, что разработчики не могут предоставить пользователю понятный результат работы их приложения, а инвестировать в то, что непонятну ютехнологию, скрытую под капотом приложения не хочется.
* Понимая многоуровневые компоненты модели OSI Блокчейна и то, как они работают вместе, мы можем определить области для инвестиционных возможностей, области уязвимости / монополии, отраслевые пробелы и недостающие элементы, которые нужны, чтобы задать тренд на блокчейн-технологию.

---
### 10. Основные недостатки блокчейн-сетей на примерах различных платформ
Тема хорошо раскрыта в англоязычной [статье](https://www.researchgate.net/publication/330028734_The_Advantages_and_Disadvantages_of_the_Blockchain_Technology) (также там есть формулы для расчета параметров блокчейна).

В теории технология блокчейна может помочь решить проблему прозрачности, надежности, достоверности и безопасности обработки данных, однако на практике реализовать это **дорого** и **сложно**. Успех внедрения напрямую зависит от государственной и законодательной поддержки.

Преимущества блокчейна:
* **Децентрализованная система** решает проблему **двойных трат** без участия посредников
  * Каждый новый блок содержит:
    1. хеш предыдущего блока
    2. временную метку
    3. хеш транзакции (точнее единый хеш - корень дерева Меркла (merkle root))
      * Транзакции включают сообщения с информацией для External owned accounts (учетных записей, принадлежащих внешним пользователям, EOAs)
    4. nonce
  * Протокол Proof-of-Work (майнер передает подобранный хеш в сеть, а остальные узлы проверяют, правильно ли решена задача)
  * Протокол Proof-of-Stake
  * Смарт-контракты - это скрипты, которые хранятся в блокчейне
* **Все действия записываются**
  * Прозрачность, достоверность, неизменность данных
* **Уменьшается время обработки и инициализации транзакции** по сравнению с банковскими организациями
  * несколько минут (или даже секунд) против 3 дня (?)

Недостатки блокчейна:
* **Высокая энергозависимость**
  * Высокое энергопотребление необходимо для доступа к реестру в реальном времени
  * Майнеры тратят огромные вычислительные мощности для поддержания работы блокчейна
  * Каждый узел блокчейна обеспечивает экстремальный уровень отказоустойчивости, гарантирует нулевое время простоя и делает данные, хранящиеся в блокчейне, навсегда неизменяемыми и устойчивыми к цензуре
    * Это нужно для достижения консенсуса (алгоритм консенсуса - одно из свойств сети, которое обеспечивает согласованность реестра всеми участниками сети)
    * Данные действия сжигают электричество и время
  * Проверка подписи также требует огромных вычислительных мощностей, так как транзакции подписаны криптографиечской схемой
* **Возможность разделения цепочки (fork)**
  * **fork** - это, по сути, результат процесса деления уже существующего блокчейна на несколько ответвлений (например у Биткоина 19 форков)
    * soft fork
    * hard fork
  * Подробнее в вопросе #12
* **Баланс между количеством узлов и выгодными затратами для пользователей**
  * Сейчас для правильной и мощной работы блокчейна не хватает узлов
    * Это значит, что пользователи платят больше, потому что узлы получают более высокие вознаграждения за работу, хотя транзакции завершаются медленнее, так как узлы работают не интенсивно
  * Со временем количество блоков в блокчейне увеличивается, следовательно повышаются требования к вычислениям, однако не все узлы могут предоставить необходимую пропускную способность, что вызывает следующие проблемы:
    * Первая: уменьшение регистра, так как узлы не могут хранить полную копию блокчейна, что означает нарушение неизменяемости и прозрачности блокчейна
    * Вторая: блокчейн становится более централизованной системой
* **Высокая стоимость реализации**
  * Средняя стоимость транзакции составляет от 75 до 160 долларов
  * Это вызвано высокой энергозависимостью (которая описывалась выше) и высокими первоначальными капитальными затраты на блокчейн
* **Сложный процесс интеграции**

---
### 11. Распространенные типы уязвимостей и атак на блокчейн-сети
Тема хорошо раскрыта в англоязычной [статье](https://www.researchgate.net/publication/330028734_The_Advantages_and_Disadvantages_of_the_Blockchain_Technology) из предыдущего вопроса.

Блокчейн может быть атакован различными угрозами, которые связаны с протоколами PoW и PoS, однако большинство из них почти невозможны:
* **Атака 51%**
  * Это когда злоумышленник захватывает 51% хэш-мощности сети. Когда такой контроль есть, можно отменить любую транзакцию и делать главной выгодную цепочку (по сути произвести двойную трату)
  * Из-за того, что алгоритм консенсуса предполагает согласие большинства участников процесса на внесение изменений в реестр блокчейна, то, теоретически, некоторое количество узлов может вступить в **сговор** и проголосовать за свою версию истории транзакций
  * Учитывая общее количество узлов системы, на практике этот сценарий реализовать практически невозможно
* **Двойная трата**
  * Это повторная (иногда множественная) продажа одних и тех же средств
  * Один покупатель переводит тот же самый баланс двум получателям транзакции. Те же деньги тратятся дважды
  * Для осуществления двойной траты нужна **отсрочка во времени** между отправкой и подтверждением/получением перевода
  * Блокчейн биткоина и других криптовалют решают проблему двойных трат через:
    * механизмы **подтверждения транзакций**
    * открытый блокчейн (**свойство прозрачности**)
  * **Пример**: Предположим, у вас есть 1 BTC, который вы пытаетесь потратить дважды. Вы совершили 1 транзакцию BTC торговцу №1. Теперь вы снова подписываете и отправляете тот же 1 BTC на другой биткоин-адрес, чтобы попытаться обмануть торговца №2. Обе транзакции идут в неподтвержденный пул транзакций. Но только первая транзакция получила подтверждение и была проверена майнерами, заключена в блок. Вторая транзакция не может получить достаточного количества подтверждений, потому что майнеры считают ее недействительной.
  * Если обе транзакции приняты майнерами одновременно, то в мемпул будет добавлена та, у которой больше подтверждений (это несколько блоков, содержащих другие транзакции, которые добавляются в цепь)
* **Sybil’s attack (Атака Сивиллы)**
  * Sybil Атака представляет собой угрозу безопасности в онлайн системе, где один человек пытается захватить сеть, создав несколько учетных записей, узлов или компьютеров
  * Это может быть также просто, как один человек, создающий несколько учетных записей в социальной сети. Но в мире криптовалют более подходящим примером будет, что кто-то запускает сразу несколько узлов в blockchain цепочке
  * Слово «Sybil» в своём названии происходит из тематического исследования о женщине по имени Sybil Dorsett, которая лечилась от диссоциативного расстройства личности, также называемого "множественного расстройства личности"
  * Атакующие могут избегать настоящих узлов в сети, если они создают достаточное количество поддельных или идентичных (Sybil идентификаторов). Затем они могут отказаться от приема или передачи блоков, эффективно блокируя других пользователей в сети
  * В действительно крупномасштабных Sybil атаках, где злоумышленникам удается контролировать большое количество вычислительной мощности или хешрейта, они могут совершить **атаку в 51%**. В таком случае, они смогут изменять порядок транзакций и не допускать подтверждения новых. Они смогут даже отменять транзакции, которые совершались во время их контроля, что может привести к **двойным тратам**
  * Многие блокчейны используют разные "алгоритмы конценсуса" для защиты от Sybil атак:
    * доказательство работы (Proof-of-Work)
    * доказательство доли (Proof-of-Stake)
    * делегированное доказательство доли (Delegated-Proof-of-Stake)
  * Эти алгоритмы консенсуса, фактически не предотвращают Sybil атаку, они просто делают ее нецелесообразной, в случае если атакующий успешно её выполнил
  * Например, blockchain Биткоина применяет определенный набор правил, для генерации новых блоков. Одно из правил заключается в том, что **способность создавать блок, должна быть пропорциональна общей вычислительной мощности механизма Proof of Work**. Это означает, что вам фактически необходимо владеть своей компьютерной мощностью, требуемой для создания нового блока, что делает процесс взлома очень сложным и дорогостоящим для злоумышленника
* **DDoS-атака**
  * Еще один тип хакерских атак, идея которого заключается в пересылке большого количества похожих запросов. Биткойн имеет встроенную защиту от атак типа "отказ в обслуживании"
  * Например, размер блока ограничен до 1 МБ, чтобы усложнить забивание пулов памяти полных узлов, а размер каждого скрипта не превышает 10 тыс. байт. Также ограничено число проверок подписи, которое может затребовать блок (20 тыс.), и количество мультиподписей (20 ключей максимум)
  * При этом клиенты биткойна блокируют все подозрительные узлы и транзакции. Например, в последней версии клиента Bitcoin Satoshi добавили функцию для регистрации нестандартных транзакций (больше 100 килобайт). Также при обработке транзакций клиент проверяет, что все выходы являются "не потраченными"
* **Взлом криптографической системы**
  * Возможно, если использовать **квантовые алгоритмы**, такие как **алгоритм Шора (Shora)**, которые могут взломать шифрование RSA.
  * Алгоритм Шора - квантовый алгоритм факторизации (разложения числа на простые множители)
  * Значимость алгоритма Шора заключается в том, что с его помощью (при использовании квантового компьютера с несколькими тысячами логических кубитов (квантовых битов)) становится возможным взлом криптографических систем с открытым ключом
  * К примеру, RSA использует открытый ключ M, являющийся произведением двух больших простых чисел. Один из способов взломать шифр RSA - найти множители M. При достаточно большом M это практически невозможно сделать, используя известные классические алгоритмы
  * Алгоритм Шора, используя возможности квантовых компьютеров, способен произвести факторизацию числа за очень короткий промежуток времени. С математической точки зрения, это потребует логарифмического (`log(N)`),а не экспоненциального (`exp(N)`)количества времени (то есть практически так же быстро, как происходит само шифрование)
* **Race attack (атака-гонка)**
  * Это когда злоумышленник посылает одну и ту же монету очень быстро на два разных адреса. А продавец принимает факт оплаты без подтверждений от сети
* **Brute force attack**
  * Это когда транзакция майнится злоумышленником на форке сети

---
### 12. Понятие хардфорка, его причины и последствия. Примеры хардфорков в различных сетях
Русскоязычная [статья](https://vc.ru/finance/347805-forki-bitkoina-chto-eto-i-chem-horoshi) по теме.

**fork** - это, по сути, результат процесса деления уже существующего блокчейна на несколько ответвлений (например у Биткоина 19 форков). То есть, на основе оригинального блокчейна Биткоина создаётся новая монета с улучшенными характеристиками самого Биткоина.

Существует два вида fork'а:
* **soft fork** - это обратно совместимое изменение протокола блокчейна, которое позволяет вводить новые правила, не требуя от всех пользователей обновления своего программного обеспечения
  * При soft fork'е большинство майнеров сети внедряют новые правила и начинают следовать обновленной версии блокчейна. Остальная часть сети может продолжать следовать старой версии блокчейна, но они не смогут проверять новые блоки, которые следуют обновленным правилам
  * Поскольку программный soft fork обратно совместим, он не приводит к созданию нового блокчейна или разделению сети
* **hard fork** - это изменение протокола блокчейна, которое не является обратно совместимым и требует от всех пользователей обновления своего программного обеспечения, чтобы продолжать участвовать в сети.
  * При hard fork'е сеть разделяется на две отдельные версии: ту, которая следует новым правилам, и ту, которая следует старым правилам
  * Если новый fork увеличивает размер блока с 1 МБ до 2 МБ и старый блок прошел через все правила hard fork'а, то блок будет принят, даже если блок ранее **не был в цепочке (?)**

Зачем нужны fork'и?
* Форки позволяют внести определенные изменения в работу сети
  * Например, fork монеты может работать на другом алгоритме (переход с PoW на PoS)
* Позволяют исправить баги или недоработки сети
  * Например, монета с большей памятью, большей скоростью майнинга, лучшей децентрализацией или масштабируемостью
* С помощью форков можно создать новый продукт на основе уже проверенной технологии блокчейн

Разница между soft fork и hard fork:
* hard fork подразумевает использование **либо** оригинальной монеты, **либо** её fork'а (**сеть разделяется**). Пользователь должен определиться, какую монету он собирается использовать
* soft fork'и же позволяют **совмещать** оригинальную и fork монету (**сеть не разделяется**)

Популярные fork'и Биткоина:
* Bitcoin Cash (BCH)
* Bitcoin Gold (BTG)
* Bitcoin Diamond (BCD)
* Lightning Bitcoin (LBTC)

---
### 17. Блокчейн. Его основные характеристики
**Блокчейн** - это распределенный реестр, который хранится на независимых друг от друга компьютерах. Данные в реестре обновляются только когда вносятся новые записи, и при условии, что они содержат одобренные большинством пользователей зашифрованные транзакции.

**Свойства блокчейна**:
* Распределенность
  * Данные хранятся на всех компьютерах сети одновременно. Каждый компьютер сам отвечает за обновление и синхронизацию.
* Необратимость записи
  * Записи можно добавлять, но не удалять. Никто не может изменить уже одобренные транзакции
* Неоспаримость владения
  * В информации о каждой транзакции содержатся данные, которые однозначно подтверждают баланс на счету каждого из участников сети.
* Прозрачность
  * Необратимость записи и неоспоримость владения позволяют каждому участнику просмотреть данные по обновлениям системы, начиная с самой первой транзакции.
* Алгоритм консенсуса
  * Общая версия реестра согласована всеми участниками сети.

Распределенный реестр, в отличие от централизованного, не имеет единого "пункта управления", и это свойство сильно усложняет варианты мошенничества с данными, которые он содержит.

Технология блокчейна лежит в основе криптовалюты Биткоин.

**Биткоин** - система платежей, где все транзакции совершаются **без участия посредников**, созданная Сатоши Накомото 1 ноября 2008 года. Биткоин возник как реакция на неадекватные действия крупных банков и был призван защитить простых людей от мошенничества. Неуязвимость Биткоина основана не на том, что реестр информации невозможно взломать, а на том, что это **бессмысленно**.

[Видео-демонстрация](andersbrownworth.com) того, как работает каждая из частей блокчейна (хэширование, подбор nonce и т.д) 

Сферы применения:
* Криптовалюта
  * Примеры проектов: Ethereum
* Государственное управление
  * Примеры проектов: Borderless, ID2020
* Электронное голосование
  * Примеры проектов: Follow My Vote, E-Residency
* Авторское право
  * Примеры проектов: Ascribe
* Маркировка бриллиантов (?)
  * Примеры проектов: Everledger
* Медицина
  * Примеры проектов: MedRec
* Логистика (Цепочки поставок)
  * Примеры проектов: Blockverify

---
## Дополнительные материалы

### Разница между IP-адресом и MAC-адресом
**MAC-адрес** - это физический адрес, **идентифицирующий** фактическое устройство в локальной сети.
* MAC - Media Access Control
* 48-битный (6 байт) шестнадцатеричный адрес
* Канальный (2) уровень сетевой модели OSI
* Записан на **сетевую интерфейсную карту (NIC)** устройства, поэтому его можно изменить, только заменив NIC

**IP-адрес** - это логический адрес, **характеризующий местоположение** вашего устройства в сети Интернет.
* IP - Internet Protocol
* Виды адреса (разные версии протокола):
    * IPv4 - это 32-битный (4 байта) адрес
    * IPv6 - это 128-битный (16 байт) адрес
* Сетевой (3) уровень сетевой модели OSI
* IP-адреса обычно предоставляются администратором сети или Интернет-провайдерами (ISP, Internet service provider)
* Люди редко используют IP номера адресов напрямую, вместо этого используют **DNS-имена**, которые приложение переводит в соответствующий номер

### Разница между TCP и UDP протоколами
TCP и UDP протоколы - основные протоколы Траспортного (4) уровня модели OSI.

**TCP (Transmission Control Protocol, протокол управления передачей)** - это протокол, который гарантирует доставку данных в корректном виде (например, с помощью контрольной суммы).
* Он жёстко следит за каждым битом информации, но работает гораздо медленнее UDP.
* Используется например, при авторизации - нам важно передать последовательность символов в правильном порядке.
* TCP-пакет намного сложнее, чем UDP

**UDP (User Datagram Protocol, протокол пользовательских датаграмм)** - протокол, который не проверяет цельность битов, его задача - как можно быстрее передать данные с одного устройства на другое.
* Используется например, при передачи видео или аудио - там, где небольшие потери некритичны, зато важна скорость передачи данных.
* Несмотря на то, что UDP не гарантирует доставку, в нем помимо портов и IP есть поле контрольной суммы.

Полезные ссылки:
* [Что такое модель OSI и зачем она нужна: препарируем слоёный пирог интернета](https://skillbox.ru/media/code/chto-takoe-model-osi-i-zachem-ona-nuzhna-prepariruem-sloyenyy-pirog-interneta/)
* [Разница между IP-адресом и MAC-адресом](https://raznisa.ru/raznica-mezhdu-ip-adresom-i-mac-adresom/)
* [TCP против UDP или будущее сетевых протоколов](https://habr.com/ru/company/oleg-bunin/blog/461829/)

### vlan, vxlan, macvlan, veth
**vlan (Virtual Local Area Network, виртуальная локальная компьютерная сеть)** - группа устройств, имеющих возможность взаимодействовать между собой напрямую на Канальном (2) уровне, хотя физически при этом они могут быть подключены к разным сетевым коммутаторам.
* vlan основывается на работе протокола **802.1q**
* Используется для разделения подсетей
* В отличие от Ethernet-кадра 802.1q-кадр содержит **Тег**
* Самое популярное применение vlan-ов: логическое объединение узлов в группы независимо от их физического расположения, то есть изоляция одной группы узлов от другой. Очень удобно, когда сотрудники физически работают в разных местах, но должны быть объединены. И конечно с точки зрения безопасности vlan не заменимы. Главное, чтобы к сетевым устройствам имели доступ ограниченный круг лиц. Добились ограничения на Канальном (2) уровне.
* [Основы компьютерных сетей. Тема №6. Понятие VLAN, Trunk и протоколы VTP и DTP](https://habr.com/ru/post/319080/)

**vxlan (Virtual Extensible LAN, виртуальная расширяемая локальная сеть)** - это протокол туннелирования. Он решает проблему недостаточного количества идентификаторов vlan (всего 4096) при разделении крупномасштабных сетей.

**macvlan** - это, по сути, Linux switch, который основан на **статичном соответствии MAC и VLAN**. Здесь используется unicast-фильтрация, не promiscuous-режим. macvlan может работать в режиме private, VEPA, bridge, passthru. macvlan - это reverse VLAN в Linux. Данная технология позволяет взять один реальный интерфейс и сделать на его основе несколько виртуальных с разными MAC-адресами.

**veth (Виртуальный Ethernet)** - это локальный туннель Ethernet.

**Сетевой интерфейс** - физическое или виртуальное устройство, предназначенное для передачи данных между программами через компьютерную сеть.
* eth - сетевой интерфейс к карте Ethernet или картам WaveLan (Radio Ethernet).
* wlan - сетевой интерфейс wi-fi адаптеров
